/**camreceiver
 * This program read video data generated by a camstream
 * compatible device and display them using Qt.
 * The program must be able to detect and resynchronize after a lost packet,
 * it will resynchronize and recover on the next image header (and drop one
 * image).
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>
#include <errno.h>
#include <sys/time.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "camstream.h"
#include "display.h"

#define USE_TCP

#define IMAGE_RINGBUFFER_SIZE	8
#define SOCKET_BUFFER_SIZE	(1*1024*1024)	/* buffer of the socket, VERY important in UDP */

#define CREATE_RINGBUFFER(_name_, _type_, _ringsize_) \
struct _name_##_ringbuffer_t { \
	_type_ ring[_ringsize_]; \
	int next_ready; \
	int next_free; \
	pthread_mutex_t lock; \
	pthread_cond_t queue; \
} _name_ = { \
	next_ready: 0, \
	next_free: 0, \
	lock: PTHREAD_MUTEX_INITIALIZER, \
	queue: PTHREAD_COND_INITIALIZER, \
};

#define RINGBUFFER_SIZE(_name_) (sizeof(_name_.ring)/sizeof(_name_.ring[0]))

/* Synchronization variables */
static int flush = 0;
static char *destfile;
static int enable_save = 0, enable_display = 0;
static double disprate = 1;
CREATE_RINGBUFFER(images, struct camstream_image_t *, IMAGE_RINGBUFFER_SIZE);

int help(char *name)
{	printf("%s: receive a camstream compatible UDP stream and display\n"
		"or save it to disk.\n"
		"Syntax: %s [ --port <port> ] [ --count <nframes> ]\n"
		"\t[ --save <file> ] [ --display [ --disprate <rate> ] ]\n"
		"\t[ --sockbuf <bufsize> ] | --help\n"
		"--port <port>: Wait for connection on <port>.\n"
		"--count <nframes>: number of frames to receive.\n"
		"--save <file>: if set the stream will be saved to <file>.\n"
		"--display: if set the stream will be displayed using Qt.\n"
		"--disprate <rate>: floating point number specifying the amount\n"
		"\tof frames to display (1=all (default), 0.5=every other etc ...).\n"
		"--sockbuf <bufsize>: set the size of the socket receive buffer.\n"
	        "--first: expand first line of image\n"
		"--help: display this message.\n"
		"\n", name, name);
	return 0;
}

unsigned long long gettime(void)
{	struct timeval t;

	gettimeofday(&t, NULL);
	return t.tv_sec*1000000+t.tv_usec;
}

int usequence;

void *writing_main(void *arg)
{	unsigned long long start_save_time, end_save_time, total_save_time = 0;
	unsigned long long start_display_time, end_display_time, total_display_time = 0;
	unsigned long frames_count = 0;
	int fd = -1;

	if (enable_save) {
		printf("Preparing to write to %s ... ", destfile);
		fd = open(destfile, O_WRONLY | O_TRUNC | O_CREAT);
		if (fd < 0) {
			printf("failed.\n");
			fprintf(stderr, "ERROR: failed to open %s: %s.\n", destfile, strerror(errno));
			exit(errno);
		}
		printf("done.\n");
	}
	if (enable_display) {
		printf("Initializing display ... ");
		display_init();
		printf("done.\n");
	}
	pthread_mutex_lock(&images.lock);
	while (1) {
		while(images.next_free == images.next_ready)
			if(flush) {
				pthread_mutex_unlock(&images.lock);
				if(enable_save) close(fd);
				printf("Writing thread terminated.\n");
				if(enable_save) 
					printf("Saved %lu frames at %lluus/frame.\n", 
							frames_count, total_save_time/frames_count);
				if(enable_display) 
					printf("Displayed %lu frames at %lluus/frame.\n", 
							frames_count/(int)(1/disprate), total_display_time/(frames_count/(int)(1/disprate)));
				return NULL;
			} else {
				pthread_cond_wait(&images.queue, &images.lock);
			};
		pthread_mutex_unlock(&images.lock);
		if(enable_save) {
			char *p = (char *)images.ring[images.next_ready];
			unsigned long size = sizeof(*images.ring[images.next_ready]) + images.ring[images.next_ready]->size;
			start_save_time = gettime();
			while (size) {
				int ret = write(fd, p, size);
				if (ret < 0) {
					fprintf(stderr, "ERROR: failed to write image to disk: %s.\n",strerror(errno));
					fprintf(stderr, "ERROR: disabled write to disk.\n");
					close(fd);
					enable_save = 0;
					break;
				}
				size -= ret;
				p += ret;
			}
			end_save_time = gettime();
			total_save_time += end_save_time - start_save_time;
		}
		if (enable_display && ((frames_count%(int)(1/disprate)) == 0)) {
			start_display_time = gettime();
			display_image(
					images.ring[images.next_ready]->data,
					images.ring[images.next_ready]->size,
					images.ring[images.next_ready]->width,
					images.ring[images.next_ready]->height
				);
			end_display_time = gettime();
			total_display_time += end_display_time - start_display_time;
		}
		if (!usequence)
		  free(images.ring[images.next_ready]);
		frames_count++;
		pthread_mutex_lock(&images.lock);
		images.next_ready++;
		if(images.next_ready == RINGBUFFER_SIZE(images))
			images.next_ready = 0;		
	}
	pthread_mutex_unlock(&images.lock);
	if(enable_save) close(fd);
	return NULL;		
}

int main (int argc, char *argv[])
{	int sockfd, ret;
	int port = CAMSTREAM_DEFAULT_PORT;
	usequence = 0;
	int ufirst = 0;
	char* ufirstbuffer;
	char* useqbuffer;
	struct sockaddr_in listen_addr;
	unsigned long long start_time, end_time, total;
	pthread_t writing_thread;
	unsigned long nframes = ~0, dropped, i;
	char *buffer;
	int sockbufsz = SOCKET_BUFFER_SIZE, sockbufsz_real;
	socklen_t sockbufsz_real_len = sizeof(sockbufsz_real);

	/* Parse the command line and check arguments */
	for (i = 1; i < argc; i++) {
		if (strcmp("--help", argv[i]) == 0) {
			help(argv[0]);
			return 0;
		} else if (strcmp("--port", argv[i]) == 0) {
			port = atoi(argv[++i]);
		} else if (strcmp("--count", argv[i]) == 0) {
			nframes = atol(argv[++i]);
		} else if (strcmp("--save", argv[i]) == 0) {
			destfile = argv[++i];
			enable_save = 1;
		} else if (strcmp("--display", argv[i]) == 0) {
			enable_display = 1;
		} else if (strcmp("--disprate", argv[i]) == 0) {
			disprate = atof(argv[++i]);
		} else if (strcmp("--sockbuf", argv[i]) == 0) {
			sockbufsz = atoi(argv[++i]);
		} else if (strcmp("--first", argv[i]) == 0) {
			ufirst = 1;
		} else if (strcmp("--sequence", argv[i]) == 0) {
			usequence = 1;
		} else {
			fprintf(stderr, "ERROR: invalid argument %s, "
					"try --help.\n", argv[i]);
			return -EINVAL;
		}
	}

	ufirstbuffer = (char*)malloc(1024*1024);
	useqbuffer   = (char*)malloc(sizeof(struct camstream_image_t)+1024*1024);

	printf("Initializing application data ... ");
	/* Start the writing thread */
	ret = pthread_create(&writing_thread, NULL, writing_main, NULL);
	if(ret != 0) {
		printf("failed.\n");
		fprintf(stderr, "ERROR: pthread_create(): %s.\n", strerror(ret));
		return -ret;
	}
	buffer = (char *)malloc(sizeof(struct camstream_image_t));
	if(buffer == NULL) {
		printf("failed.\n");
		fprintf(stderr, "ERROR: could not allocate %d bytes.\n", CAMSTREAM_PKT_MAXSIZE);
		return -ENOMEM;
	}
	printf("done.\n");

	/* Open the socket and connection */
	printf("Initializing connection ... ");
	listen_addr.sin_family = AF_INET;
	listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	listen_addr.sin_port = htons(port);
#ifdef USE_TCP
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd < 0) {
		printf("failed.\n");
		perror("ERROR: socket() failed");
		free(buffer);
		return -errno;
	}
#else
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printf("failed.\n");
		perror("ERROR: socket() failed");
		free(buffer);
		return -errno;
	}
#endif
	ret = bind(sockfd, (struct sockaddr *)&listen_addr, sizeof(listen_addr));
	if (ret < 0) {
		printf("failed.\n");
		perror("ERROR: bind() failed");
		close(sockfd);
		free(buffer);
		return -errno;
	}
	ret = setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &sockbufsz, sizeof(int));
	if (ret < 0) {
		printf("failed.\n");
		perror("ERROR: setsockopt() failed");
		close(sockfd);
		free(buffer);
		return -errno;
	}
	/* Check the value is correct, it may not be if the kernel 
	 * does not allow a socket buffer to be as big as specified
	 */
	ret = getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &sockbufsz_real, &sockbufsz_real_len);
	if (ret < 0) {
		printf("failed.\n");
		perror("ERROR: getsockopt() failed");
		close(sockfd);
		free(buffer);
		return -errno;
	}
	/* Note: the allocated buffer is always double of what was requested on Linux systems
 	 * (it is related to some BSD compatibility thing and the way Linux handles socket
	 * buffers
	 */
	if (sockbufsz_real != sockbufsz*2) {
		printf("failed.\n");
		fprintf(stderr, "WARNING: a socket buffer of %dB was denied, it is %dB.\n",
				sockbufsz, sockbufsz_real);
		printf("HINT: on Linux, increase the sysctl property net.core.rmem_max.\n");
		printf("continue ... ");
	}
	printf("done, waiting on port %d.\n", ntohs(listen_addr.sin_port));
#ifdef USE_TCP
	ret = listen(sockfd, 1);
	if (ret < 0) {
		perror("ERROR: listen() failed");
		close(sockfd);
		free(buffer);
		return -errno;
	}
	ret = accept(sockfd, NULL, 0);
	if (ret < 0) {
		perror("ERROR: accept() failed");
		close(sockfd);
		free(buffer);
		return -errno;
	}
	close(sockfd);
	sockfd = ret;
#else
#if 0
	/* Wait for a connection */
	{	fd_set fdset;
		FD_ZERO(&fdset);
		FD_SET(sockfd, &fdset);
		ret = select(sockfd+1, &fdset, NULL, NULL, NULL);
		if (ret < 0) {
			perror("ERROR: select() failed");
			close(sockfd);
			free(buffer);
			return -errno;
		}
	}
#endif
#endif
	/* We receive the data */
	start_time = gettime();
	for (total = 0, i = 0, dropped = 0; i < nframes; i++) {
		struct camstream_image_t *p = (struct camstream_image_t *)buffer;
		struct camstream_image_t *image;
		ssize_t pktsize;
		unsigned long tx;
		uint32_t imgsize, imgwidth, imgheight;
		int sync = 1;
		int useqrow,useqoff;

		printf("\rWaiting for image %lu ... ", i+1);
		/* First we receive the header */
		while(1) {
			pktsize = recv(sockfd, buffer, sizeof(struct camstream_image_t), 0);
			if (pktsize < 0) {
				printf("failed.\n");
				perror("ERROR: recv() failed");
				close(sockfd);
				free(buffer);
				return -errno;
			}
			if(pktsize == 0)
				break;
			total += pktsize;
			if (p->base.hdr != CAMSTREAM_IMAGE_HDR) {
				if(sync) {
					printf("invalid header, skipping.\nWaiting for image %lu ...   ", i);			
					sync = 0;
				}
				continue;
			}
			sync = 1;
			if ((pktsize != sizeof(struct camstream_image_t)) 
				|| (p->base.pktsize != CAMSTREAM_IMAGE_PKTSIZE)) {
				/* Broken/corrupted packet, we cannot handle it */
				dropped++;
				i++;
				printf("corrupted header, skipping.\nWaiting for image %lu ...   ", i);
				continue;
			}
			break;
		};

		/* Means connection is closed */
		if(pktsize == 0) {
			printf("aborted:\nConnection closed by sender.");
			break;
		}
		imgsize   = ntohl(p->size  );
		imgheight = ntohs(p->height);
		imgwidth  = ntohs(p->width );

		if (usequence) {
		  useqrow = i%imgheight;
		  useqoff = useqrow*imgwidth;
		  printf("\rReceiving row %lu off %lu ...   ", useqrow, useqoff);
		  image = useqbuffer;
		}
		else
		  image = (struct camstream_image_t *)
		    malloc(sizeof(struct camstream_image_t) + imgsize);
		if (image == NULL) {
			printf("failed.\n");
			fprintf(stderr, "ERROR: could not allocate %d Bytes for image.\n", 
					sizeof(struct camstream_image_t) + imgsize);
			close(sockfd);
			free(buffer);
			return -errno;
		}
		for (tx = 0; tx < imgsize; tx += pktsize, total += pktsize) {
		  if (usequence) {
		    if (tx < imgwidth)
			pktsize = recv(sockfd, 
				       (char*)image + sizeof(struct camstream_image_t) + tx + useqoff,
				       imgwidth - tx,
				       MSG_WAITALL);
		    else
			pktsize = recv(sockfd, ufirstbuffer, imgsize-tx, MSG_WAITALL);
		  }				       
		  else
			pktsize = recv(sockfd, ((char *)image)+sizeof(struct camstream_image_t)+tx, imgsize-tx, MSG_WAITALL);
		  if (pktsize < 0) {
		    printf("failed.\n");
		    perror("ERROR: recv() failed");
		    close(sockfd);
		    free(buffer);
		    return -errno;
		  }
		}

		/* Finish filling the packet info */
		image->base.hdr = CAMSTREAM_IMAGE_HDR;
		image->base.pktsize = CAMSTREAM_IMAGE_PKTSIZE;
		image->format = p->format;
		image->size = imgsize;
		image->width = imgwidth;
		image->height = imgheight;
		image->data = (char *)((unsigned long)(&image->data) + ntohl((unsigned long)p->data));
		/* special transformation */
		if (ufirst) {
		  int k;
		  for(k = 1; k < image->height; k++)
		    memcpy( image->data + k*image->width, image->data, image->width );
		}

		/* Notify writing thread that an image is available */
		pthread_mutex_lock(&images.lock);
		if((images.next_free+1)%RINGBUFFER_SIZE(images) == images.next_ready) {
			printf("image queue full, image dropped !\n");
			dropped++;
			pthread_mutex_unlock(&images.lock);
			continue;
		}
		images.ring[images.next_free] = image;
		images.next_free++;
		if(images.next_free == RINGBUFFER_SIZE(images))
			images.next_free = 0;
		pthread_cond_signal(&images.queue);
		pthread_mutex_unlock(&images.lock);
		fflush(stdout);
	}
	printf("\n");
	pthread_mutex_lock(&images.lock);
	flush=1;
	pthread_cond_signal(&images.queue);
	pthread_mutex_unlock(&images.lock);
	pthread_join(writing_thread, NULL);
	end_time = gettime();
	close(sockfd);
	free(buffer);
	printf("\rReceived %lu images in %0.3fs.\n", i, ((double)(end_time-start_time))/1000000);
	printf("Transferred a total of %llu Bytes at a rate of %0.3fMbps.\n", total, (double)(total*8)/(end_time-start_time));
	if (dropped)
		printf("%lu images were dropped.\n", dropped);
	printf("\n");
	return 0;
}
