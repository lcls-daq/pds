#include "pds/evgr/EvrSlaveFIFOHandler.hh"

#include "pds/xtc/InDatagram.hh"
#include "pds/utility/Appliance.hh"
#include "pds/utility/StreamPorts.hh"
#include "pds/service/Ins.hh"
#include "pds/service/Task.hh"
#include "pds/xtc/EvrDatagram.hh"
#include "evgr/evr/evr.hh"

#include <new>
#include <string.h>
#include <signal.h>
#include <byteswap.h>

using namespace Pds;

static bool evrHasEvent(Evr& er);

/*
 * Signal handler, for processing the incoming event codes, and providing interfaces for
 *   retrieving L1 data from the L1Xmitter object
 * The Slave EVR process is indicated by L1Xmitter::enable.  The master is responsible
 * for sending the EvrDatagram to the other segment levels, generating the sw triggers, 
 * adding the FIFO data to the L1Accept datagram, and counting events for calibration cycles.
 * All EVR processes configure the
 * EVRs to generate hardware triggers.  The slave EVR processes only need verify that
 * their FIFO data matches the timestamp of the L1Accept generated by the master.
 */
EvrSlaveFIFOHandler::EvrSlaveFIFOHandler(Evr&       er,
					 Appliance& app,
					 unsigned   partition,
					 Task*      task,
                                         Task*      sync_task) :
  bEnabled            (false),
  _er                 (er),
  _app                (app),
  _evtCounter         (0), 
  _bReadout           (false),
  _pEvrConfig         (NULL),
  _sem                (Semaphore::EMPTY),
  _rdptr              (0),
  _wrptr              (0),
  _sync               (*this, er, partition, task, sync_task),
  _tr                 (0)
{
  memset( _lEventCodeState, 0, sizeof(_lEventCodeState) );
}
  
EvrSlaveFIFOHandler::~EvrSlaveFIFOHandler()
{
}
  
void EvrSlaveFIFOHandler::fifo_event(const FIFOEvent& fe)
{      
  if ( _sync.handle(fe) )
    return;

  /*
  if ( bShowFirst == true ) 
    {
      timespec ts;
      clock_gettime(CLOCK_REALTIME, &ts);
      printf("EvrSlaveFIFOHandler first fifo event at %d.%09d\n",
	     int(ts.tv_sec), int(ts.tv_nsec));
      bShowFirst = false;
    }
  */

  if ( bEnabled == false ) 
    {
      printf("EvrSlaveFIFOHandler::xmit(): during Disabled, vector %d code %d fiducial 0x%x last 0x%x timeLow 0x%x\n", 
             _evtCounter, fe.EventCode, fe.TimestampHigh, _lastFiducial, fe.TimestampLow);
    }
    
  if (fe.EventCode == TERMINATOR) {            
    // TERMINATOR will not be stored in the event code list
    if (_bReadout)
      startL1Accept(fe, false);
    return;
  }

  uint32_t        uEventCode = fe.EventCode;
  EventCodeState& codeState  = _lEventCodeState[uEventCode];
    
  if ( codeState.iDefReportWidth == 0 )// not an interesting event
    ;    
  else if ( codeState.bReadout ) 
    {
      _lastFiducial = fe.TimestampHigh;
      _bReadout     = true;           
    }
}

InDatagram* EvrSlaveFIFOHandler::l1accept(InDatagram* in)
{
  InDatagram* out = in;

  _sem.take();

  TimeStamp ts = _ts[(_rdptr++)%QSize];

  // check counter,fiducial match => set damage if failed
  // 2013-05-17 Comment out the fiducial check until CXI problems are better understood
//  if (ts.fiducials() != in->datagram().seq.stamp().fiducials())
//  {
//    printf("EvrSlaveFIFOHandler out of order on %x : vector %x  fiducials %x  wrptr %x  rdptr %x\n",
//           in->datagram().seq.stamp().fiducials(),
//	   ts.vector(), ts.fiducials(), _wrptr, _rdptr);
//    out->datagram().xtc.damage.increase(Pds::Damage::OutOfOrder);
//  }
        
  return out;
}

Transition* EvrSlaveFIFOHandler::enable      (Transition* tr)
{
  clear();
  _wrptr = _rdptr = 0;
  _sem   = Semaphore(Semaphore::EMPTY);  
  bEnabled = true; 
  bShowFirst = true;
  return tr;
}

Transition* EvrSlaveFIFOHandler::disable     (Transition* tr)
{
  _tr = tr;
  return (Transition*)Appliance::DontDelete;
}

void EvrSlaveFIFOHandler::get_sync() 
{
  _sync.enable();
}

void EvrSlaveFIFOHandler::release_sync()
{
  clear();
  //  _sem.give();   // sometimes we get one less FIFO event than the master
  bEnabled = false; 

  _app.post(_tr);
}

void        EvrSlaveFIFOHandler::set_config  (const EvrConfigType* pEvrConfig)
{
  _pEvrConfig = pEvrConfig; 
    
  memset( _lEventCodeState, 0, sizeof(_lEventCodeState) );

  unsigned int uEventIndex = 0; 
  for ( ; uEventIndex < _pEvrConfig->neventcodes(); uEventIndex++ )
    {
      const EvrConfigType::EventCodeType& eventCode = _pEvrConfig->eventcode( uEventIndex );
      if ( eventCode.code() >= guNumTypeEventCode )
        {
          printf( "EvrSlaveFIFOHandler::setEvrConfig(): event code out of range: %d\n", eventCode.code() );
          continue;
        }
      
      EventCodeState& codeState = _lEventCodeState[eventCode.code()];
      codeState.bReadout        = eventCode.isReadout   ();
      codeState.bCommand        = eventCode.isCommand   ();
      codeState.iDefReportDelay = eventCode.reportDelay ();
      if (eventCode.isLatch())
        codeState.iDefReportWidth = -eventCode.releaseCode();             
      else
        codeState.iDefReportWidth = eventCode.reportWidth ();             

      printf("EventCode %d  readout %c  command %c  latch %c  delay %d  width %d\n",
             eventCode.code(),
             eventCode.isReadout() ? 't':'f',
             eventCode.isCommand() ? 't':'f',
             eventCode.isLatch  () ? 't':'f',
             eventCode.reportDelay(),
             eventCode.reportWidth());
    }    
}  

Transition* EvrSlaveFIFOHandler::config      (Transition* tr)
{
  clear();
  _evtCounter = 0;
  return tr;
}

Transition* EvrSlaveFIFOHandler::endcalib    (Transition* tr)
{
  return tr;
}


void EvrSlaveFIFOHandler::startL1Accept(const FIFOEvent& fe, bool bEvrDataIncomplete)
{    
  static pthread_t        tid   = -1;
  static pthread_mutex_t  mutex   = PTHREAD_MUTEX_INITIALIZER; 
    
  if ( pthread_equal(tid, pthread_self()) )
    {
      printf("EvrSlaveFIFOHandler::startL1Accept(): Re-entry call for vector %d fiducial 0x%x last 0x%x timeLow 0x%x code %d\n",
             _evtCounter, fe.TimestampHigh,
             _lastFiducial, fe.TimestampLow, fe.EventCode );
      return;
    }
  tid = pthread_self();        
    
  if ( pthread_mutex_lock(&mutex) )
    {
      printf("EvrSlaveFIFOHandler::startL1Accept(): pthread_mutex_lock() failed\n");
      return;
    }
    
  if ( !_bReadout )
    {
      if ( pthread_mutex_unlock(&mutex) )
        printf( "EvrSlaveFIFOHandler::startL1Accept(): pthread_mutex_unlock() failed\n" );
            
      printf("EvrSlaveFIFOHandler::startL1Accept(): No readout/commands detected. Possibly called by two threads.\n");
      tid = -1;
      return;          
    }
    
  /*
  if (fe.TimestampHigh == 0 && uFiducialPrev < 0x1fe00) // Illegal fiducial wrap-around
    {
      printf("EvrSlaveFIFOHandler::startL1Accept(): [%d] vector %d fiducial 0x%x prev 0x%x Incomplete %c last 0x%x timeLow 0x%x code %d\n",
             uNumBeginCalibCycle, _evtCounter, fe.TimestampHigh, uFiducialPrev, (bEvrDataIncomplete?'Y':'n'),
             _lastFiducial, fe.TimestampLow, fe.EventCode );
    }
  */
      
  if (_bReadout) 
    {
      _ts[(_wrptr++)%QSize] = TimeStamp(fe.TimestampLow, fe.TimestampHigh, _evtCounter);
      _sem.give();
    }

  _bReadout  = false;
    
  if ( pthread_mutex_unlock(&mutex) )
    printf( "EvrSlaveFIFOHandler::startL1Accept(): pthread_mutex_unlock() failed\n" );
      
  tid = -1;
} 

void EvrSlaveFIFOHandler::clear()        
{ 
  const int iMaxCheck = 10;
  int       iCheck    = 0;
  while ( evrHasEvent(_er) && ++iCheck <= iMaxCheck )
    { // sleep for 2 millisecond to let signal handler process FIFO events
      timeval timeSleepMicro = {0, 2000}; // 2 milliseconds  
      select( 0, NULL, NULL, NULL, &timeSleepMicro);       
    }
    
  if (iCheck > iMaxCheck)
    {
      printf("EvrSlaveFIFOHandler::clear quit after %d checks\n",iCheck);
    }

  if (_bReadout)
    {
      FIFOEvent fe;
      fe.TimestampHigh    = _lastFiducial;
      fe.TimestampLow     = 0;
      fe.EventCode        = TERMINATOR;      

      /*
      if (fe.TimestampHigh == 0 && uFiducialPrev < 0x1fe00) // Illegal fiducial wrap-around
        printf("EvrSlaveFIFOHandler::clear(): [%d] Call startL1Accept() with vector %d fiducial 0x%x prev 0x%x last 0x%x timeLow 0x%x\n", 
               uNumBeginCalibCycle, _evtCounter, fe.TimestampHigh, uFiducialPrev, _lastFiducial, fe.TimestampLow);
      */
        
      startL1Accept(fe, true);      
    }
}

// check if evr has any unprocessed fifo event
bool evrHasEvent(Evr& er)
{    
  uint32_t& uIrqFlagOrg = *(uint32_t*) ((char*) &er + 8);  
  uint32_t  uIrqFlagNew = be32_to_cpu(uIrqFlagOrg);
  
  if ( uIrqFlagNew & EVR_IRQFLAG_EVENT)
    return true;
  else
    return false;
}
