#include "pds/evgr/EvrMasterFIFOHandler.hh"

#include "pds/evgr/EvrDataUtil.hh"
#include "pds/service/Timer.hh"
#include "pds/service/Task.hh"
#include "pds/service/TaskObject.hh"
#include "pds/utility/Mtu.hh"
#include "pds/xtc/EvrDatagram.hh"
#include "pds/collection/Route.hh"
#include "pds/evgr/EvrManager.hh"
#include "pds/utility/Appliance.hh"
#include "pds/utility/Occurrence.hh"
#include "pds/utility/StreamPorts.hh"
#include "pds/xtc/CDatagram.hh"
#include "pds/xtc/EnableEnv.hh"
#include "pds/utility/Transition.hh"

#include <new>
#include <string.h>
#include <signal.h>
#include <byteswap.h>
#include <stdlib.h>

static const unsigned syncCode = 40;

namespace Pds
{
  class DoneTimer:public Timer
  {
  public:
    DoneTimer(Appliance & app):_app(app),
      _pool(sizeof(Occurrence), 1), _task(new Task(TaskObject("donet")))
    {
    }
     ~DoneTimer()
    {
      _task->destroy();
    }
  public:
    void set_duration_ms(unsigned v)
    {
      _duration = v;
    }
  public:
    void expired()
    {
      _app.post(new(&_pool) Occurrence(OccurrenceId::SequencerDone));
    }
    Task *task()
    {
      return _task;
    }
    unsigned duration() const
    {
      return _duration;
    }
    unsigned repetitive() const
    {
      return 0;
    }
  private:
    Appliance &           _app;
    GenericPool           _pool;
    Task *                _task;
    unsigned              _duration;
  };
};

using namespace Pds;

static void _print_L1(const ClockTime& iTriggerCounter, 
		      const EvrL1Data& evrL1Data)
{
  printf("Trigger counter: %d.%09d, Current Data counter: %d.%09d\n"
          "  Read Index = %d, Write Index = %d\n", 
	 iTriggerCounter.seconds(),
	 iTriggerCounter.nanoseconds(),
	 evrL1Data.getCounterRead().seconds(),
	 evrL1Data.getCounterRead().nanoseconds(),
	 evrL1Data.readIndex(), evrL1Data.writeIndex() );
}

static long long int timeDiff(timespec* end, timespec* start) {
  long long int diff;
  diff =  (end->tv_sec - start->tv_sec) * 1000000000LL;
  diff += end->tv_nsec;
  diff -= start->tv_nsec;
  return diff;
}

static bool evrHasEvent(Evr& er);

/*
 * Signal handler, for processing the incoming event codes, and providing interfaces for
 *   retrieving L1 data from the L1Xmitter object
 * The Master EVR process is indicated by L1Xmitter::enable.  The master is responsible
 * for sending the EvrDatagram to the other segment levels, generating the sw triggers, 
 * adding the FIFO data to the L1Accept datagram, and counting events for calibration cycles.
 * All EVR processes configure the
 * EVRs to generate hardware triggers.  The slave EVR processes only need verify that
 * their FIFO data matches the timestamp of the L1Accept generated by the master.
 */
EvrMasterFIFOHandler::EvrMasterFIFOHandler(Evr&       er, 
                                           const Src& src,
                                           Appliance& app,
                                           unsigned   partition,
                                           int        iMaxGroup,
					   unsigned   neventnodes,
					   bool       randomize,
                                           Task*      task):
  uFiducialPrev       (0),
  _er                 (er),
  _app                (app),
  _done               (new DoneTimer(app)),
  _outlet             (sizeof(EvrDatagram), 0, Ins   (Route::interface())),  
  _swtrig_out         (Route::interface(), Mtu::Size, 16),
  _swtrig_dst         (StreamPorts::event(partition,Level::Observer)),
  _src                (src),
  _poolEvrData        (sizeof(CDatagram) + sizeof(Xtc) + EvrDataUtil::size( giMaxNumFifoEvent ),16),
  _evtCounter         (0), 
  _evtStop            (0), 
  _iMaxGroup          (iMaxGroup),
  _uMaskReadout           (0),
  _pEvrConfig         (NULL),
  _L1DataUpdated      ( *(EvrDataUtil*) new char[ EvrDataUtil::size( giMaxNumFifoEvent ) ]  ),
  _L1DataLatchQ       ( *(EvrDataUtil*) new char[ EvrDataUtil::size( giMaxNumFifoEvent ) ]  ),
  _L1DataLatch        ( *(EvrDataUtil*) new char[ EvrDataUtil::size( giMaxNumFifoEvent ) ]  ),
  _bEvrDataFullUpdated(false),
  _ncommands          (0),
  _evrL1Data          (giMaxNumFifoEvent, giNumL1Buffers),
  _sync               (*this, er, partition, task, _outlet, app),
  _tr                 (0),
  _nnodes             (neventnodes),
  _randomize_nodes    (randomize)
{
  _lSegEvtCounter.resize(1+_iMaxGroup, 0);
  for (int iGroup=0; iGroup <= _iMaxGroup; ++iGroup)
    _ldst.push_back(StreamPorts::event(partition,Level::Segment, iGroup));    
  
  new (&_L1DataUpdated) EvrDataUtil( 0, NULL );
  new (&_L1DataLatch)   EvrDataUtil( 0, NULL );    
  new (&_L1DataLatchQ)  EvrDataUtil( 0, NULL );    
    
  memset( _lEventCodeState, 0, sizeof(_lEventCodeState) );

  timespec tv;
  clock_gettime(CLOCK_REALTIME, &tv);
  srand(tv.tv_nsec);
}
  
EvrMasterFIFOHandler::~EvrMasterFIFOHandler()
{
  delete _done;
  delete[] (char*) &_L1DataUpdated;
  delete[] (char*) &_L1DataLatch;    
  delete[] (char*) &_L1DataLatchQ;
}
  
void EvrMasterFIFOHandler::fifo_event(const FIFOEvent& fe)
{      
  if ( _sync.handle(fe) )
    return;

  /*
  if ( bShowFirst == true )
    {
      timespec ts;
      clock_gettime(CLOCK_REALTIME, &ts);
      printf("EvrMasterFIFOHandler first fifo event at %d.%09d\n",
       int(ts.tv_sec), int(ts.tv_nsec));
      bShowFirst = false;
    }
  */

  if ( bEnabled == false ) 
    {
      printf("EvrMasterFIFOHandler::xmit(): [%d] during Disabled, vector %d code %d fiducial 0x%x prev 0x%x last 0x%x timeLow 0x%x\n", 
             uNumBeginCalibCycle, _evtCounter, fe.EventCode, fe.TimestampHigh, uFiducialPrev, _lastFiducial, fe.TimestampLow);
    }
    
  /*
   * Determine if we need to start L1Accept
   *
   * Rule: If we have got an readout event before, and get the terminator event now,
   *    then we will start L1Accept 
   */
     
  if (fe.EventCode == TERMINATOR) {            
    // TERMINATOR will not be stored in the event code list
    if (_uMaskReadout != 0 || _ncommands) 
      {        
        if (fe.TimestampHigh == 0 && uFiducialPrev < 0x1fe00) // Illegal fiducial wrap-around
          printf("EvrMasterFIFOHandler::xmit(): [%d] Call startL1Accept() with vector %d fiducial 0x%x prev 0x%x last 0x%x timeLow 0x%x\n", 
                 uNumBeginCalibCycle, _evtCounter, fe.TimestampHigh, uFiducialPrev, _lastFiducial, fe.TimestampLow);
        startL1Accept(fe, false);
      }
      
    return;
  }

  uint32_t        uEventCode = fe.EventCode;
  EventCodeState& codeState  = _lEventCodeState[uEventCode];
    
  if ( codeState.iDefReportWidth == 0 )// not an interesting event
    {
      if ( uEventCode == (unsigned) EvrManager::EVENT_CODE_BEAM  || // special event: Beam present -> always included in the report
           uEventCode == (unsigned) EvrManager::EVENT_CODE_BYKIK    // special event: Dark frame   -> always included in the report
           )
        addSpecialEvent( _L1DataUpdated, *(const EvrDataType::FIFOEvent*) &fe );
        
      return;
    }
    
  if ( codeState.uMaskReadout != 0 ) 
    {
      addFifoEventCheck( _L1DataUpdated, *(const EvrDataType::FIFOEvent*) &fe );      
      _lastFiducial = fe.TimestampHigh;
      _uMaskReadout |= codeState.uMaskReadout;
      //printf("event %d readout [0x%x]\n", uEventCode, codeState.uMaskReadout);//!!!debug
      return;
    }

  if ( codeState.bCommand )
    {
      _lastFiducial = fe.TimestampHigh;
      addCommand( fe );            
      //      return;
    }
    
  /*
   * The readout and command codes are processed above.
   * Now start to process the control-transient and control-latch codes
   */    

  /*
   *  Removed "latched" event codes if its partner ("release") code is found
   */
  { 
    bool eventDeleted = false;
    for (unsigned int uEventIndex = 0; uEventIndex < _L1DataLatchQ.numFifoEvents(); uEventIndex++ )
      {
        const EvrDataType::FIFOEvent& fifoEvent = _L1DataLatchQ.fifoEvent( uEventIndex );
        EventCodeState&               codeState = _lEventCodeState[fifoEvent.EventCode];
        if (codeState.iReportWidth == -int(uEventCode)) 
          {
            _L1DataLatchQ.markEventAsDeleted( uEventIndex );
            eventDeleted = true;
          }
      }
    for (unsigned int uEventIndex = 0; uEventIndex < _L1DataLatch.numFifoEvents(); uEventIndex++ )
      {
        const EvrDataType::FIFOEvent& fifoEvent = _L1DataLatch.fifoEvent( uEventIndex );
        EventCodeState&               codeState = _lEventCodeState[fifoEvent.EventCode];
        if (codeState.iReportWidth == -int(uEventCode)) 
          {
            _L1DataLatch.markEventAsDeleted( uEventIndex );
            eventDeleted = true;
          }
      }
        
    if ( eventDeleted )
      {
        _L1DataLatch .purgeDeletedEvents();          
        _L1DataLatchQ.purgeDeletedEvents();          
      }
  }
      
  if (codeState.iReportWidth > 0) {
    if (codeState.iReportDelayQ <= 0) {
      updateFifoEventCheck( _L1DataLatchQ, *(const EvrDataType::FIFOEvent*) &fe );
      codeState.iReportDelayQ = codeState.iDefReportDelay;
    }
    else {
      printf("EvrMasterFIFOHandler::xmit(): Can't queue eventcode %d\n",fe.EventCode);
    }
  }
  else {
    updateFifoEventCheck( _L1DataLatch, *(const EvrDataType::FIFOEvent*) &fe );
    codeState.iReportDelay = codeState.iDefReportDelay;
    codeState.iReportWidth = codeState.iDefReportWidth;
  }
}

InDatagram* EvrMasterFIFOHandler::l1accept(InDatagram* in)
{
  InDatagram* out = in;

  do {
    if ( _poolEvrData.numberOfFreeObjects() <= 0 )
      {
        printf( "EvrL1Action::fire(): Pool is full, so cannot provide buffer for new datagram\n" );
        break;
      }      

    const ClockTime&   iTriggerCounter  = in->seq.clock();
    int                iVector          = in->seq.stamp().vector();
    bool               bDataFull        = _evrL1Data.getDataReadFull();
    bool               bDataInc         = _evrL1Data.getDataReadIncomplete();
      
    const EvrDataUtil* pEvrData         = NULL;
    bool               bOutOfOrder      = false;
      
    getL1Data(iTriggerCounter, pEvrData, bOutOfOrder);

    if ( bShowFirstFiducial )
      {
        printf("First Vector %3d Fiducial 0x%x prev 0x%x last 0x%x\n", 
               in->seq.stamp().vector(), in->seq.stamp().fiducials(), uFiducialPrev, _lastFiducial );
        bShowFirstFiducial = false;
      }
    else if ( bShowFiducial )
      printf("Vector %3d Fiducial 0x%x prev 0x%x last 0x%x\n", 
             in->seq.stamp().vector(), in->seq.stamp().fiducials(), uFiducialPrev, _lastFiducial );
      
    bool bNoL1Data = ( pEvrData == NULL );
    if ( bNoL1Data )
      {
        static const EvrDataUtil evrDataEmpty( 0, NULL );      
        pEvrData = &evrDataEmpty;        
      }
      
    const EvrDataUtil& evrData = *pEvrData;
      
    out = new ( &_poolEvrData ) CDatagram( in->datagram() ); 
    out->datagram().xtc.alloc( sizeof(Xtc) + evrData.size() );
      
    unsigned int  uFiducialCur  = out->datagram().seq.stamp().fiducials();  
            
    if ( bDataInc )
      {
        //printf( "EvrL1Action::fire(): Incomplete data.\n" );
        printf( "EvrL1Action::fire(): [%d] Incomplete data with vector %d fiducial 0x%x prev 0x%x last 0x%x\n", 
                uNumBeginCalibCycle, iVector, uFiducialCur, uFiducialPrev, _lastFiducial );
        out->datagram().xtc.damage.increase(Pds::Damage::UserDefined);              
        out->datagram().xtc.damage.userBits(0x1);        
        
        if ( evrHasEvent(_er) )
          {
            printf( "EvrL1Action::fire(): Found unprocessed FIFO event, which may cause missing triggers\n" );
            out->datagram().xtc.damage.userBits(out->datagram().xtc.damage.userBits() | 0x4);
          }        
      }
      
    if ( uFiducialPrev != 0 )
      {
        const int iFiducialWrapAroundDiffMin = 65536; 
        if ( (uFiducialCur <= uFiducialPrev && uFiducialPrev < uFiducialCur+iFiducialWrapAroundDiffMin) )
          {
            // !! In burst mode, this is not a error, so we don't set the damage bit, but just print out the information
            printf( "EvrL1Action::fire(): seq 0x%x followed 0x%x\n", uFiducialCur, uFiducialPrev );
            //out->datagram().xtc.damage.increase(Pds::Damage::UserDefined);      
            //out->datagram().xtc.damage.userBits(out->datagram().xtc.damage.userBits() | 0x2);
          }
      }
    uFiducialPrev = uFiducialCur;
            
    if ( bDataFull )
      {
        printf( "EvrL1Action::fire(): Too many FIFO events recieved, so L1 data buffer is full and incomplete.\n" );
        printf( "  Please check the readout and terminator event settings.\n" );        
        out->datagram().xtc.damage.increase(Pds::Damage::UserDefined);      
        out->datagram().xtc.damage.userBits(out->datagram().xtc.damage.userBits() | 0x8);
      }      

    if ( bNoL1Data )
      {
        out->datagram().xtc.damage.increase(Pds::Damage::UserDefined);
        out->datagram().xtc.damage.userBits(out->datagram().xtc.damage.userBits() | 0x10);
      }
        
    /*
     * Set Evr object
     */    
    char* pcXtc = (char*) out + sizeof(CDatagram);        
    TypeId typeEvrData(TypeId::Id_EvrData, EvrDataUtil::Version);
    Xtc* pXtc = 
      new (pcXtc) Xtc(typeEvrData, _src);
    pXtc->alloc( evrData.size() );   

    char*  pcEvrData = (char*) (pXtc + 1);  
    new (pcEvrData) EvrDataUtil(evrData);
      
    //if (  evrData.numFifoEvents() > 1 ) // !! debug print
    if ( uFiducialCur == 0 && uFiducialPrev < 0x1fe00) // Illegal fiducial wrap-around
      {
        printf( "EvrL1Action::fire(): [%d] vector %d fiducial 0x%x prev 0x%x\n", 
                uNumBeginCalibCycle, iVector, uFiducialCur, uFiducialPrev );
        printf( "EvrL1Action::fire() data dump start (size = %u bytes)\n", evrData.size() );
        evrData.printFifoEvents();
        printf( "EvrL1Action::fire() data dump end\n\n" );
      }
    //
    //  Test for fiducial mismatch and set outoforder damage
    //
      
    if (!bNoL1Data && !bOutOfOrder)
      releaseL1Data();      
  } 
  while (false);
    
  //
  //  Special software trigger service to L1 nodes
  //
  out->send(_swtrig_out, _swtrig_dst);

  return out;
}

Transition* EvrMasterFIFOHandler::enable      (Transition* tr)
{
  // reset the fiducial checking counter
  uFiducialPrev = 0; 
  bShowFirstFiducial  = true;
  bShowFiducial       = false;
    
  //
  //  Calibration cycle event counting
  //
  const EnableEnv& env = static_cast<const EnableEnv&>(tr->env());
  _evtStop = _evtCounter + env.events();

  if (env.timer()) 
    {
      _done->set_duration_ms(env.duration());
      _done->start();
    }
    
  nextEnable(); // clear the unprocessed events from previous Enable-Disable    
  bEnabled = true; 

  return tr;
}

void EvrMasterFIFOHandler::get_sync()
{
  timespec ts;
  ts.tv_sec = 0; 
  ts.tv_nsec = 20000000;
  nanosleep(&ts,0);

  _sync.initialize(true);
  bShowFirst = true;
}

void EvrMasterFIFOHandler::release_sync()
{
  bShowFirstFiducial  = false;
  bShowFiducial       = true;

  _done->cancel();

  clear();
    
  bEnabled = false; 

  _app.post(_tr);
}

Transition* EvrMasterFIFOHandler::disable     (Transition* tr)
{
  _tr = tr;
  _sync.initialize(false);
  return (Transition*)Appliance::DontDelete;
}

void        EvrMasterFIFOHandler::set_config  (const EvrConfigType* pEvrConfig)
{
  _pEvrConfig = pEvrConfig; 
    
  memset( _lEventCodeState, 0, sizeof(_lEventCodeState) );
  
  for ( unsigned int uEventIndex = 0; uEventIndex < _pEvrConfig->neventcodes(); uEventIndex++ )
    {
      const EvrConfigType::EventCodeType& eventCode = _pEvrConfig->eventcode( uEventIndex );
      if ( eventCode.code() >= guNumTypeEventCode )
        {
          printf( "EvrMasterFIFOHandler::setEvrConfig(): event code out of range: %d\n", eventCode.code() );
          continue;
        }
      
      EventCodeState& codeState = _lEventCodeState[eventCode.code()];
      codeState.uMaskReadout    |= (eventCode.isReadout() ? (1<<eventCode.readoutGroup()): 0);
      codeState.bCommand        = eventCode.isCommand   ();
      codeState.iDefReportDelay = eventCode.reportDelay ();
      if (eventCode.isLatch())
        codeState.iDefReportWidth = -eventCode.releaseCode();             
      else
        codeState.iDefReportWidth = eventCode.reportWidth ();             

      printf("EventCode %d  readout %c group %d mask 0x%x command %c  latch %c  delay %d  width %d\n",
             eventCode.code(),
             eventCode.isReadout() ? 'Y':'n',
             eventCode.readoutGroup(),
             codeState.uMaskReadout,
             eventCode.isCommand() ? 'Y':'n',
             eventCode.isLatch  () ? 'Y':'n',
             eventCode.reportDelay(),
             eventCode.reportWidth());
    }    
}  

Transition* EvrMasterFIFOHandler::config      (Transition* tr)
{
  reset();
  uNumBeginCalibCycle = 0;
  return tr;
}

Transition* EvrMasterFIFOHandler::endcalib    (Transition* tr)
{
  ++uNumBeginCalibCycle;
  return tr;
}


void EvrMasterFIFOHandler::startL1Accept(const FIFOEvent& fe, bool bEvrDataIncomplete)
{    
  static pthread_t        tid   = -1;
  static pthread_mutex_t  mutex   = PTHREAD_MUTEX_INITIALIZER; 
    
  if ( pthread_equal(tid, pthread_self()) )
    {
      printf("EvrMasterFIFOHandler::startL1Accept(): [%d] Re-entry call for vector %d fiducial 0x%x prev 0x%x Incomplete %c last 0x%x timeLow 0x%x code %d\n",
             uNumBeginCalibCycle, _evtCounter, fe.TimestampHigh, uFiducialPrev, (bEvrDataIncomplete?'Y':'n'),
             _lastFiducial, fe.TimestampLow, fe.EventCode );
      return;
    }
  tid = pthread_self();        
    
  if ( pthread_mutex_lock(&mutex) )
    {
      printf("EvrMasterFIFOHandler::startL1Accept(): pthread_mutex_lock() failed\n");
      return;
    }
    
  if ( !(_uMaskReadout != 0 || _ncommands) )
    {
      if ( pthread_mutex_unlock(&mutex) )
        printf( "EvrMasterFIFOHandler::startL1Accept(): pthread_mutex_unlock() failed\n" );
            
      printf("EvrMasterFIFOHandler::startL1Accept(): No readout/commands detected. Possibly called by two threads.\n");
      tid = -1;
      return;          
    }
    
  if (fe.TimestampHigh == 0 && uFiducialPrev < 0x1fe00) // Illegal fiducial wrap-around
    {
      printf("EvrMasterFIFOHandler::startL1Accept(): [%d] vector %d fiducial 0x%x prev 0x%x Incomplete %c last 0x%x timeLow 0x%x code %d\n",
             uNumBeginCalibCycle, _evtCounter, fe.TimestampHigh, uFiducialPrev, (bEvrDataIncomplete?'Y':'n'),
             _lastFiducial, fe.TimestampLow, fe.EventCode );
    }

  unsigned vector;
  if (_randomize_nodes) {
    //
    //  Schedule the event node destinations for the next batch of events
    //
    unsigned node_index = _evtCounter%_nnodes;
    if (node_index==0) {
      for(unsigned i=0; i<_nnodes; i++) _vector[i]=-1;
      for(unsigned i=0; i<_nnodes; i++) {
	const unsigned NBITS=24;
	const unsigned NB_MASK=((1<<NBITS)-1);
	unsigned j = ((_nnodes-i)*(rand()&NB_MASK))>>NBITS;
	for(unsigned k=0; (1); k++) {
	  if (_vector[k]<0) 
	    if (j-- == 0) {
	      _vector[k] = i;
	      break;
	    }
	}
      }
    }
    vector = _evtCounter - node_index + _vector[node_index];
  }
  else {
    vector = _evtCounter;
  }

  timespec ts;
  clock_gettime(CLOCK_REALTIME, &ts);
  ClockTime ctime(ts.tv_sec, ts.tv_nsec);
  TimeStamp stamp(fe.TimestampLow, fe.TimestampHigh, vector);

  if (_evtCounter == 0)
  {
    _lastTime.tv_nsec = ts.tv_nsec;
    _lastTime.tv_sec = ts.tv_sec;
  }

  if (_uMaskReadout == 0) 
  {
    Sequence seq(Sequence::Occurrence, TransitionId::Unknown, ctime, stamp);
    EvrDatagram datagram(seq, _evtCounter, _ncommands);
    for (int iGroup = 0; iGroup < (int) _ldst.size(); ++iGroup)
    {
      datagram.evr = _lSegEvtCounter[iGroup];
      _outlet.send((char *) &datagram, _commands, _ncommands, _ldst[iGroup]);
    }
  }
  else 
    {
      Sequence seq(Sequence::Event, TransitionId::L1Accept, ctime, stamp);
      EvrDatagram datagram(seq, _evtCounter++, _ncommands);
                  
      if ( ! _evrL1Data.isDataWriteReady() )
        {
          printf( "EvrMasterFIFOHandler::startL1Accept(): Previous Evr Data has not been transferred out.\n"
                  "  Current data will be reported in next round.\n");
	  _print_L1(ctime, _evrL1Data);
        }
      else
        {
          EvrDataUtil& _lL1DataFianl = _evrL1Data.getDataWrite();
        
          _evrL1Data.setCounterWrite (ctime);

          /* 
           * Process delayed & enlongated events
           */
          bool bAnyLatchedEventDeleted = false;
          for (unsigned int uEventIndex = 0; uEventIndex < _L1DataLatchQ.numFifoEvents(); uEventIndex++ )
            {
              const EvrDataType::FIFOEvent& fifoEvent = _L1DataLatchQ.fifoEvent( uEventIndex );
              EventCodeState&               codeState = _lEventCodeState[fifoEvent.EventCode];
            
              if ( codeState.iReportWidth  <= 0 ||
                   codeState.iReportDelayQ <= 0 )
                {
                  updateFifoEventCheck( _L1DataLatch, fifoEvent );
                  _L1DataLatchQ.markEventAsDeleted( uEventIndex );
                  bAnyLatchedEventDeleted = true;
                  codeState.iReportDelay  = codeState.iReportDelayQ;
                  codeState.iReportWidth  = codeState.iDefReportWidth;
                  codeState.iReportDelayQ = 0;
                  continue;
                }
            
              --codeState.iReportDelayQ;
            }

          if ( bAnyLatchedEventDeleted ) {
            _L1DataLatchQ.purgeDeletedEvents();     
            bAnyLatchedEventDeleted = false;
          }
          
          for (unsigned int uEventIndex = 0; uEventIndex < _L1DataLatch.numFifoEvents(); uEventIndex++ )
            {
              const EvrDataType::FIFOEvent& fifoEvent = _L1DataLatch.fifoEvent( uEventIndex );
              EventCodeState&               codeState = _lEventCodeState[fifoEvent.EventCode];
                                       
              if ( codeState.iReportDelay > 0 )
                {
                  --codeState.iReportDelay;
                  continue;
                }
      
              /*
               * Add the latched events to final buffer
               */
              addFifoEventCheck( _lL1DataFianl, fifoEvent );
            
              /*
               * Test if any control-transient event codes has expired.
               */
              if (codeState.iReportWidth>=0) // control-latch codes will bypass this test, since its report width = -1 * (release code)
                {
                  if ( --codeState.iReportWidth <= 0 )
                    {
                      _L1DataLatch.markEventAsDeleted( uEventIndex );
                      bAnyLatchedEventDeleted = true;
                    }
                }
            }
    
          if ( bAnyLatchedEventDeleted ) {
            _L1DataLatch .purgeDeletedEvents();  
            bAnyLatchedEventDeleted = false;
          }
        
          for (unsigned int uEventIndex = 0; uEventIndex < _L1DataUpdated.numFifoEvents(); uEventIndex++ )
            {
              const EvrDataType::FIFOEvent& fifoEvent =  _L1DataUpdated.fifoEvent( uEventIndex );
              addFifoEventCheck( _lL1DataFianl, fifoEvent );
            }                    
        
          _evrL1Data.setDataWriteFull       ( _bEvrDataFullUpdated );
          _evrL1Data.setDataWriteIncomplete ( bEvrDataIncomplete );
          _evrL1Data.finishDataWrite        ();
    
          _L1DataUpdated.clearFifoEvents();
          _bEvrDataFullUpdated = false;
                    
        } // else ( ! _evrL1Data.isDataWriteReady() )
    
      static const int NEVENTPRINT = 1000;      
      if (_evtCounter%NEVENTPRINT == 0) 
        {
          clock_gettime(CLOCK_REALTIME, &_thisTime);
          long long int nanoseconds = timeDiff(&_thisTime, &_lastTime);
          float rate = 1000.0 / (nanoseconds * 1.e-9);
          printf("Evr event %d, high/low 0x%05x/0x%x, rate(Hz): %7.2f\n",
                 _evtCounter, fe.TimestampHigh, fe.TimestampLow, rate);
          _lastTime.tv_nsec = _thisTime.tv_nsec;
          _lastTime.tv_sec  = _thisTime.tv_sec;
        }

      if (_evtCounter == _evtStop)
        _done->expired();                     
              
      /*
       * Send out the L1 "trigger" to make all L1 node start processing.
       *
       * Note: As soon as the send() function is called, the other polling thread may
       *   race with this thread to get the evr data and send it out immediately.
       */
   
      _uMaskReadout |= 0x1; // Readout group 0 is always triggered
      datagram.setL1AcceptEnv(_uMaskReadout);
      unsigned int uGroupBit = 1;
      for (int iGroup = 0; iGroup <= _iMaxGroup; ++iGroup, uGroupBit <<= 1)      
      {
        if ( (_uMaskReadout & uGroupBit) != 0 )
        {
          //printf("sending L1 trigger for group %d\n", iGroup);//!!!debug
          datagram.evr = _lSegEvtCounter[iGroup];
          ++_lSegEvtCounter[iGroup];
          _outlet.send((char *) &datagram, _commands, _ncommands, _ldst[iGroup]);  //!!! for supporting segment group
        }
      }        
    } // else (_uMaskReadout == 0) 

  _uMaskReadout  = 0;  
  _ncommands = 0;
    
  if ( pthread_mutex_unlock(&mutex) )
    printf( "EvrMasterFIFOHandler::startL1Accept(): pthread_mutex_unlock() failed\n" );
      
  tid = -1;
} 

void EvrMasterFIFOHandler::clear()        
{ 
  const int iMaxCheck = 10;
  int       iCheck    = 0;
  while ( evrHasEvent(_er) && ++iCheck <= iMaxCheck )
    { // sleep for 2 millisecond to let signal handler process FIFO events
      timeval timeSleepMicro = {0, 2000}; // 2 milliseconds  
      select( 0, NULL, NULL, NULL, &timeSleepMicro);       
    }
    
  if (_uMaskReadout != 0 || _ncommands) 
    {
      FIFOEvent fe;
      fe.TimestampHigh    = _lastFiducial;
      fe.TimestampLow     = 0;
      fe.EventCode        = TERMINATOR;      

      if (fe.TimestampHigh == 0 && uFiducialPrev < 0x1fe00) // Illegal fiducial wrap-around
        printf("EvrMasterFIFOHandler::clear(): [%d] Call startL1Accept() with vector %d fiducial 0x%x prev 0x%x last 0x%x timeLow 0x%x\n", 
               uNumBeginCalibCycle, _evtCounter, fe.TimestampHigh, uFiducialPrev, _lastFiducial, fe.TimestampLow);
        
      startL1Accept(fe, true);      
    }
  //_L1DataUpdated.clearFifoEvents();
  //_L1DataLatch  .clearFifoEvents();
  //_L1DataLatchQ .clearFifoEvents();
        
  /**
   * Note: Don't call _evrL1Data.reset() to clear the L1 Data buffer here,
   *   because the un-processed L1 Data will be sent out in the Disable action
   */
}

void EvrMasterFIFOHandler::nextEnable()
{ 
  const int iMaxCheck = 10;
  int       iCheck    = 0;
  while ( evrHasEvent(_er) && ++iCheck <= iMaxCheck )
    { // sleep for 2 millisecond to let signal handler process FIFO events
      timeval timeSleepMicro = {0, 2000}; // 2 milliseconds  
      select( 0, NULL, NULL, NULL, &timeSleepMicro);       
    }
    
  if (_uMaskReadout != 0 || _ncommands) 
    {
      FIFOEvent fe;
      fe.TimestampHigh    = _lastFiducial;
      fe.TimestampLow     = 0;
      fe.EventCode        = TERMINATOR;      

      printf("EvrMasterFIFOHandler::nextEnable(): [%d] Call startL1Accept() with vector %d fiducial 0x%x prev 0x%x last 0x%x timeLow 0x%x\n", 
             uNumBeginCalibCycle, _evtCounter, fe.TimestampHigh, uFiducialPrev, _lastFiducial, fe.TimestampLow);
        
      startL1Accept(fe, true);
    }
  else
    {
      _evrL1Data.reset();
    }
    
  _L1DataUpdated.clearFifoEvents();
  _L1DataLatch  .clearFifoEvents();
  _L1DataLatchQ .clearFifoEvents();
        
  /**
   * Note: Don't call _evrL1Data.reset() to clear the L1 Data buffer here,
   *   because the un-processed L1 Data will be sent out in the Disable action
   */
}
  
void EvrMasterFIFOHandler::reset()        
{
  clear();    
  _evrL1Data.reset();
  _evtCounter = 0;
  _lSegEvtCounter.assign(_lSegEvtCounter.size(), 0);
}

int EvrMasterFIFOHandler::getL1Data(const ClockTime& iTriggerCounter, const EvrDataUtil* & pEvrData, bool& bOutOfOrder) 
{  
  pEvrData    = NULL; // default return value: invalid data
  bOutOfOrder = false;

  if ( ! _evrL1Data.isDataReadReady() )
    {
      printf( "EvrMasterFIFOHandler::getL1Data(): No L1 Data ready: ");
      _print_L1(iTriggerCounter,_evrL1Data);
      return 1; // Will set Dropped Contribution damage for L1 Data
    }    
    
  /*
   * Normal case: current data counter == trigger counter
   */
  if ( _evrL1Data.getCounterRead() == iTriggerCounter )
    {
      pEvrData = & _evrL1Data.getDataRead();    
      return 0;      
    }

  /*
   * Error cases:
   *
   * Case 1: Current data counter is later than the trigger counter
   *   
   *   In this case, we will do nothing to the existing data     
   *   We just return an error code to indicate
   *   thre is no valid L1 data returned
   */
     
  if ( _evrL1Data.getCounterRead() > iTriggerCounter ) //  test if data is later than trigger
    {
      printf( "EvrMasterFIFOHandler::getL1Data(): Missing L1 Data: ");
      _print_L1(iTriggerCounter,_evrL1Data);
      return 2;      
    }

  /*
   * Case 2: Current data counter is earlier than trigger counter
   *   
   *   We test if there exists a data that has the same counter as the trigger
   */
  int iDataIndex =  _evrL1Data.findDataWithCounter( iTriggerCounter );
  if ( iDataIndex != -1 )
    {
      /*
       * Case 2a: Some out-of-order data matches the trigger
       *
       *   In this case, we will return corresponding data, 
       *   and mark this data as invalid, so it will not be
       *   used later
       */      
      printf( "EvrMasterFIFOHandler::getL1Data(): Recovered Out-of-order L1 Data: Data Index = %d, ",iDataIndex);
      _print_L1(iTriggerCounter, _evrL1Data);
       
      _evrL1Data.markDataAsInvalid( iDataIndex );
      pEvrData = & _evrL1Data.getDataWithIndex( iDataIndex );
      
      /* 
       *   We return a special error code to indicate that 
       *   the data is an out-of-order data, so the buffer 
       *   should not be released by client, until all earlier 
       *   data have been processed
       */
      bOutOfOrder = true;
      return 3;
    }
                 
     
  /*
   * Case 2b: No data in the buffer can match the trigger
   *
   *   In this case, we will discard the data until the remaining
   *   data is newer than the trigger
   *
   *   Then we return an error code to 
   *   indicate thre is no valid L1 data returned
   */         

  printf( "EvrMasterFIFOHandler::getL1Data(): Missing Triggers: ");
  _print_L1(iTriggerCounter, _evrL1Data);
        
  int iDataDropped = 0;
  while ( 
         _evrL1Data.isDataReadReady() &&
         ( iTriggerCounter > _evrL1Data.getCounterRead() ) // test if trigger is later than data
         )
    {
      ++iDataDropped;
      _evrL1Data.finishDataRead();
    }
    
  printf("EvrMasterFIFOHandler::getL1Data(): Dropped %d Data: ", iDataDropped);
  _print_L1(iTriggerCounter, _evrL1Data);
  return 4; // Will set Dropped Contribution damage for L1 Data
}
  
void EvrMasterFIFOHandler::releaseL1Data() 
{ 
  /*
   * For the first time setup:
   *
   * Set signal mask so that this thread will not be used 
   * as evr's signal handler
   */
  static bool bThreadSyncInit = false;        
  if (!bThreadSyncInit)
    {
      sigset_t sigetHoldIO;
      sigemptyset(&sigetHoldIO);
      sigaddset  (&sigetHoldIO, SIGIO);
      
      if ( pthread_sigmask(SIG_BLOCK, &sigetHoldIO, NULL) < 0 )
        perror( "EvrMasterFIFOHandler::releaseL1Data(): pthread_sigmask() failed" );
        
      bThreadSyncInit = true;
    }
        
  _evrL1Data.finishDataRead();     
}
    
// Add Fifo event to the evrData with boundary check
int EvrMasterFIFOHandler::addFifoEventCheck( EvrDataUtil& evrData, const EvrDataType::FIFOEvent& fe )
{
  if ( (int) evrData.numFifoEvents() < giMaxNumFifoEvent )
    return evrData.addFifoEvent(fe);
    
  _bEvrDataFullUpdated = true; // set the flag and later the L1Accept will send out damage    
  return -1;
}

// Update Fifo event to the evrData with boundary check
int EvrMasterFIFOHandler::updateFifoEventCheck( EvrDataUtil& evrData, const EvrDataType::FIFOEvent& fe )
{
  int iNewEventIndex = evrData.updateFifoEventCheck(fe, giMaxNumFifoEvent);

  if ( (int) evrData.numFifoEvents() < giMaxNumFifoEvent ) 
    return iNewEventIndex;
    
  _bEvrDataFullUpdated = true; // set the flag and later the L1Accept will send out damage    
  return -1;
}
  
/*
 * Add a special event to the current evrData
 *
 *   Also checked the evrData content to remove all "previous" (not in the same timestamp) special events,
 *     until an "interesting" event is encountered.
 *
 * Note: This algorithm is based on the assumption that
 *   - All the "interesting" events occurs later than "special" events
 *      - Current settings: All "interesting" event codes (67 - 98) occurs after all special events (140, 162)
 */
int EvrMasterFIFOHandler::addSpecialEvent( EvrDataUtil& evrData, const EvrDataType::FIFOEvent &feCur )
{
  uint32_t uFiducialCur  = feCur.TimestampHigh;
    
  for (int iEventIndex = evrData.numFifoEvents()-1; iEventIndex >= 0; iEventIndex-- )
    {
      const EvrDataType::FIFOEvent& fifoEvent  = evrData.fifoEvent( iEventIndex );
      uint32_t                      uFiducial  = fifoEvent.TimestampHigh;

      if ( uFiducial == uFiducialCur ) // still in the same timestamp. this event will be checked again in later iteration.
        break;
      
      uint32_t        uEventCode = fifoEvent.EventCode;
      EventCodeState& codeState  = _lEventCodeState[uEventCode];
    
      if ( codeState.iDefReportWidth != 0 ) // interesting event
        break;
        
      evrData.removeTailEvent();      
    }
    
  addFifoEventCheck( evrData, feCur );       
  return 0;
}
  
void EvrMasterFIFOHandler::addCommand( const FIFOEvent& fe )
{
  if (_ncommands < giMaxCommands) 
    {
      _commands[_ncommands++] = fe.EventCode;
    }
  else 
    {
      printf("Dropped command %d\n",fe.EventCode);
    }
}

// check if evr has any unprocessed fifo event
bool evrHasEvent(Evr& er)
{    
  uint32_t& uIrqFlagOrg = *(uint32_t*) ((char*) &er + 8);  
  uint32_t  uIrqFlagNew = be32_to_cpu(uIrqFlagOrg);
  
  if ( uIrqFlagNew & EVR_IRQFLAG_EVENT)
    return true;
  else
    return false;
}

