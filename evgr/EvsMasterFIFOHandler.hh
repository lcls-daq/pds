#ifndef Pds_EvsMasterFIFOHandler_hh
#define Pds_EvsMasterFIFOHandler_hh

#include <vector>
#include <time.h>

/*
 * Signal handler, for processing the incoming event codes, and providing interfaces for
 *   retrieving L1 data from the L1Xmitter object
 * The Master EVR process is indicated by L1Xmitter::enable.  The master is responsible
 * for sending the EvrDatagram to the other segment levels, generating the sw triggers, 
 * adding the FIFO data to the L1Accept datagram, and counting events for calibration cycles.
 * All EVR processes configure the
 * EVRs to generate hardware triggers.  The slave EVR processes only need verify that
 * their FIFO data matches the timestamp of the L1Accept generated by the master.
 */

#include "pds/service/Client.hh"
#include "pds/service/Ins.hh"
#include "pds/utility/ToNetEb.hh"
#include "pds/service/GenericPool.hh"
#include "pds/evgr/EvrL1Data.hh"
#include "pds/evgr/EvrSync.hh"
#include "pds/config/EvsConfigType.hh"

namespace Pds {

  class Evr;
  class Appliance;
  class Src;
  class FIFOEvent;
  class InDatagram;
  class Task;
  class Transition;
  class EvrDataUtil;
  class EvrFifoServer;
  class EvrTimer;

  class EvsMasterFIFOHandler {
  public:
    enum { guNumTypeEventCode = 256 };
    enum { giMaxCommands      = 32 };
    enum { giMaxNumFifoEvent  = 32 };
    enum { giNumL1Buffers     = 32 };
  public:
    EvsMasterFIFOHandler(Evr&, 
			   const Src&, 
			   Appliance&, 
			   EvrFifoServer&,
			   unsigned partition,
			   int      iMaxGroup,
			   unsigned neventnodes,
			   bool     randomize,
			   Task*    task);
    virtual ~EvsMasterFIFOHandler();
  public:
    virtual void        fifo_event  (const FIFOEvent&);  // formerly 'xmit'
    virtual InDatagram* l1accept    (InDatagram*);
    virtual Transition* enable      (Transition*);
    virtual Transition* disable     (Transition*);
    virtual void        set_config  (const EvsConfigType*);
    virtual Transition* config      (Transition*); // config action
    virtual Transition* endcalib    (Transition*);
    virtual void        get_sync    ();

  private:
    unsigned int          uFiducialPrev; // public data for checking fiducial increasing steps
    bool                  bShowFirstFiducial;
    bool                  bShowFiducial;
    unsigned int          uNumBeginCalibCycle;
    bool                  bEnabled;      // partition in Enabled state
    bool                  bShowFirst;
  private:
    struct EventCodeState
    {
      uint32_t  uMaskReadout;
      bool      bCommand;
      int       iDefReportDelay;
      int       iDefReportWidth;  
      int       iReportWidth;
      int       iReportDelayQ; // First-order  delay for Control-Transient events
      int       iReportDelay;  // Second-order delay for Control-Transient events; First-order delay for Control-Latch events
    };
  private:
    Evr &                 _er;
    Appliance&            _app;
    EvrFifoServer&        _srv;
    EvrTimer*             _done;
    Client                _outlet;
    std::vector<Ins>      _ldst;

    ToNetEb               _swtrig_out;
    Ins                   _swtrig_dst;
    const Src&            _src;

    GenericPool           _pool;    
    
    unsigned              _evtCounter;
    std::vector<unsigned> _lSegEvtCounter;
    unsigned              _evtStop;
    int                   _iMaxGroup;
    uint32_t              _uMaskReadout;
    EvrDataUtil&          _L1DataUpdated;     // codes that contribute to the coming L1Accept
    EvrDataUtil&          _L1DataLatchQ;      // codes that contribute to later L1Accepts. Holding first-order transient events.
    EvrDataUtil&          _L1DataLatch;       // codes that contribute to later L1Accepts. Holding second-order transient events and first-order latch events
    EventCodeState        _lEventCodeState[guNumTypeEventCode];
    bool                  _bEvrDataFullUpdated;
    unsigned              _ncommands;
    char                  _commands[giMaxCommands];
    EvrL1Data             _evrL1Data;

    unsigned              _lastFiducial;

    Transition*           _tr;
    timespec              _thisTime;
    timespec              _lastTime;

    enum { MAX_NODES=32 };
    unsigned              _nnodes;
    bool                  _randomize_nodes;
    int                   _vector[MAX_NODES];

  private:
    void startL1Accept(const FIFOEvent& fe, bool bEvrDataIncomplete);

    int  getL1Data(const ClockTime&, const EvrDataUtil* & pEvrData, bool& bOutOfOrder);
    void releaseL1Data();

    // Add Fifo event to the evrData with boundary check
    int addFifoEventCheck( EvrDataUtil& evrData, const Pds::EvrData::FIFOEvent& fe );

    // Update Fifo event to the evrData with boundary check
    int updateFifoEventCheck( EvrDataUtil& evrData, const Pds::EvrData::FIFOEvent& fe );
  
    void addCommand( const FIFOEvent& fe );

    void nextEnable();
    void clear();
    void reset();
  };
};

#endif
